### 4.5 自底向上分析概述

*自底向上分析的基本思想与主要问题：*

-   基本思想

    -   自底向上构造语法分析树, 根据**输入符,** 选择合适的**句柄**进行归约, 直至将输入符串归约为文法开始符号

        -   句柄：当前句型的**最左直接短语**
        -   归约句柄：**最左归约**

    -   移入-归约的思想

        -    自底向上分析也叫**移入-归约分析**

             >   借助**栈**来理解

        -   移入：将**输入符号**压入栈

        -   归约：从栈中依次**弹出**能构成**产生式右部**的若干个符号，然后将**左部压入栈**（最左归约）

            >   最左归约称为规范归约、最右推导称为规范推导，每次用于归约的符号串称之为**句柄**，也就是**产生式右部**

-   主要问题

    -   何时移入、何时归约、归约时用什么归约
    -   移入-归约分析中的关键问题是**正确识别句柄**

-   系统框架

    -   控制程序

    -   栈：分析栈

        >   自底向上分析中，**栈和输入**中的内容组合起来是句型，栈中的内容只是句型的**前缀**

    -   输入：输入缓冲区

    -   表：指导**语法分析树**的形成，确定**移进和归约**的时机

---

*优先法的基本思想：*

-   优先级的概念：优先级指的是**归约的优先级**

-   优先级的作用：确定何时移进何时规约
    -   **栈顶**最近的终结符优先级**小于或等于输入**符号：移入
    -   **栈顶**最近的终结符优先级**大于输入**符号：归约
        -   归约的句柄是从栈顶到第一次优先级**小于**输入的位置（不包括）

-   核心问题：优先级的确定


---

*状态法/LR分析的基本思想：*

>   从**左**到右扫描，反向构造最**右**推导

-   **状态**：

    -    用**状态**表示**句柄识别的进展程度**

         >   状态的可视化表示就是在产生式右部插入一个圆点，代表**离可以使用该产生式归约**还差什么符号，**圆点右边的符号**就是需要的符号

    -   移进状态：圆点后面是终结符

    -   待约状态：圆点后面是非终结符

    -   归约状态：圆点后面没有符号

-   **栈**：

    -    有两个栈，**状态栈与符号栈**，它们是平行的（栈中**元素个数保持相等**）

-   **分析表**：

    -    只要构造出正确的**分析表**就可以直观且快速地识别了，分析表的概述如下：

    -   内容：

        -   **一行**对应一个**状态**，一个状态的**一条边**对应于该行的**一个表项**

            >   这里的**边**指的是自动机中的边

        -   **一列**对应一个**文法符号**，终结符和结束符在**ACTION列组**，非终结符在**GOTO列组**

    -   应用：

        -   从状态栈只有初始状态0、符号栈只有结束符$开始，根据**当前状态(行)和输入符号(列)**找到表项，执行对应的操作，直到读取输入后找到的表项为acc或err

            >   acc时，栈中为S，输入缓冲中为#

        -   表项中，$s_n$代表将**所在列对应符号和状态n**同时压入栈符号栈和状态栈；$r_n$代表使用第n个产生式归约，同时弹出**产生式右部**符号(串)和与其**平行的状态**，并压入**左部非终结符**，再根据**当前栈顶状态**和**该非终结符**找到GOTO列组的项k，这代表着再**将状态k压入栈**；acc代表成功识别，err代表出错

            >   所以，**构造出文法的分析表**是LR分析的关键

### 4.4 算符优先分析法

*适合算符优先分析的文法：*

-   算符文法：

    -    文法中不存在具有**相邻非终结符**的产生式

-   算符优先文法：

    -   定义：可以根据产生式推断出**不矛盾优先级**关系的**算符文法**

    -   终结符优先级的确定：

        -   **相邻或只间隔一个非终结符**，则优先级相等

        -   经由非终结符**推导**至少一步后**相邻或只间隔一个非终结符**，则被推导出的优先级更高，且应当认为**左边**的处于**栈**中，**右边**的处于**输入缓冲**中

            >   对于不能通过产生式判断优先级的算符文法，也可以**人为规定优先级**

---

*算符优先矩阵：*

-   FIRSTOP与LASTOP

    -   非终结符的FIRSTOP集：该非终结符经过至少一步推导得到的**串首终结符或**去掉串首的**一个非终结符**后成为串首终结符的集合
    -   非终结符的LASTOP集：该非终结符经过至少一步推导得到的**串尾终结符或**去掉串尾的**一个非终结符**后成为串首终结符的集合

-   算符优先矩阵

    -   内容：

        -   行：栈内符号

        -   列：输入符号

            >   注意行列不要颠倒

    -   填写：

        -   遍历所有产生式右部的所有相邻符号，确定优先级
        -   应当认为左边的处于栈中，右边的处于输入缓冲中

-   优先函数

    -   构造方法：通过算符优先矩阵规定的偏序关系，构造DAG，计算拓扑排序，基于拓扑排序构造优先函数

    -   优点：节省存储空间

    -   缺点：错误检测能力降低

        >   详见笔记仓库

---

*算符优先法的素短语：*

-   素短语：**含终结符**且不含有更小**含终结符短语**的短语

-   算符优先法归约的是**最左素短语**，并非**最左直接短语**

### 4.5 LR分析法

>   ⭐️LR系列的相关概念较多，暂不探讨定义这些概念的内在原因，只要能将其**应用到问题中**即可

*LR(0)分析：*

-   LR(0)相关概念

    -   **增广文法**：新增开始符号，它能推导出原开始符号（$S'\rarr S$）

        >   增广文法让文法**开始符号**仅出现在一个产生式的**左边**，这样分析器**只有一个接受状态**

    -   **项目**：项目描述了**句柄识别的状态**

        -   移进项目

        -   待约项目

            >   开始符号对应的待约项目称为初始项目（$S'\rarr\cdot S$）

        -   归约项目

            >   开始符号对应的归约项目称为接收项目（$S'\rarr S\cdot$）
            >
            >   产生式$A\rarr\epsilon$只生成一个项目$A\rarr\cdot$

    -   **后继项目**：同属一个产生式但圆点只差一个符号，圆点在后的是后继项目

    -   **等价的项目/项目集闭包**：对于一个**待约**项目，它的等价项目就是，以该待约项目**圆点后面的符号**为**左部**的所有产生式将圆点放在**右部第一个符号前**得到的项目；被等价推出的**待约**项目可以继续等价推出，直到不能再推出新的待约项目。这样推出的所有项目都放在一个集合中，这个集合就是**项目集闭包**。

        >   对于移进项目和归约项目，它们可以被待约项目等价推出，但不能等价推出别的项目。如果它们不能由某个待约项目等价推出，则它们没有等价项目

    -   项目集对应于**文法符号X**(包括终结符和非终结符)的**后继项目集闭包**（`GOTO(I, X)`函数）：项目集中**圆点右紧邻符号为X**的每一个项目的**后继**项目集闭包的并

-   LR(0)自动机与分析表

    -   自动机的构造

        -   初始项目（$S'\rarr\cdot S$）的**项目集闭包**构成**状态0**
        -   对于**每一个现有状态**，求其对于**每一个文法符号(包括终结符和非终结符)**的后继项目集闭包（`GOTO(I, X)`），若`GOTO(I, X)`不为空，则将其作为一个新的状态（如果是已经存在的状态就不必当成新状态了），并生成一条当前状态指向`GOTO(T, X)`对应状态的**有向边**，边上的符号为当前文法符号
        -   循环执行2**直到不再增加有向边**

    -   分析表的构造

        -   行：所有**状态；**列：ACTION列（所有终结符+结束符）和GOTO列（除了增广的非终结符）

        -   **接收项目**是单独在一个状态里，对应**接收状态**，在表中与结束符$形成表项acc

        -   对于一个状态i（一行）

            >   一个状态中若既有**归约项目**又有其他类型的项目，则会出现冲突，这里暂不考虑

            -   出边上是**非终结符**的，对应该行的**GOTO表项**，为有向边指向的状态编号j
            -   出边上是**终结符**的，对应该行的**ACTION表项**，为有向边指向的状态$s_j$
            -   若**没有出边**，或者说状态中**只有一个归约项目**，则该行的ACTION表项全为$r_k$（k为该归约项目对应的**产生式编号**）

-   LR(0)会有**移进/归约**冲突和**归约/归约**冲突

    >   总得来说，就是该不该归约的问题

    -   对应到自动机中，就是一个状态中**同时存在归约项目和其他类型项目**，或者同时存在**多个归约项目**，导致遇到下一个输入时无法判断执行什么动作
    -   对应到分析表中，就是ACTION列组的**一个表项**会有**两个可选值**
    -   出现问题的本质原因是，LR(0)分析没有**向前查看符号**，没考虑**上下文环境**

---

*SLR分析：*

-   SLR分析基本思想

    >   S：Simple，仅通过FOLLOW集化解冲突

    -   是对LR(0)分析的改进，**在LR(0)分析的基础上**，不是**子成分**都全了就能归约的，因为归约后左部符号的**FOLLOW集**中可能没有该输入符，也就是归约后的符号可能不是**待分析句子中的一个成分**

    -   当遇到LR(0)中所述冲突时，要考察两种集合(是两种，不是两个。第一种里只有一个，第二种里可以有多个)：
        -   第一种是状态中**所有移进/待约项目**圆点右侧符号构成的集合，
        -   第二种是状态中所有**归约项目**对应产生式左部非终结符的**所有FOLLOW集**。
        
    -   当这些集合两两不相交时：

        >   若不能做到两两不相交，则说明SLR无法解决这种冲突

        -   若**输入符号**在圆点右侧符号构成的集合中，则执行对应的移进ACTION；
        -   若**输入符号**在某个归约项目左部的FOLLOW集中，则执行对应的归约ACTION。
        -   其他情况报错

-   SLR自动机与分析表

    -   自动机的构造：与LR(0)一样的

    -   分析表的构造：在LR(0)构造的分析表基础上，只有**ACTION列的终结符(输入符号)**在对应状态中归约项目左部符号的**FOLLOW集**中时，才进行归约，否则的话，要么是**移进**，要么**表项为空**

        >   若这样做之后一个表项中还是会留下多个动作，则说明SLR无法解决这种冲突

-   SLR分析中的冲突

    -   上述的两种集合不能做到**两两不相交**
    -   本质原因是，对于归约项目，输入符号在其左部**FOLLOW集**中，只是能归约一个**必要条件**，并非充分条件

---

*LR(1)分析：*

-   基本思想与概念

    -   在LR分析的**特定位置**，对于非终结符A，并非FOLLOW(A)中的所有符号都可以接在A后面，所以并不是输入符在FOLLOW(A)中了就可以使用以A为左部的这条产生式进行归约，我们需要找到**非终结符A在特定位置的后继符**

        >   也就是说，需要考虑程序**上下文**，而LR(1)就是在考虑**下文的第1个符号**

    -   规范LR(1)项目：$A\rarr\alpha\cdot\beta, a（第一分量,第二分量）$

        -   第一分量：右部带圆点的产生式（就是之前对于项目的定义）

        -   第二分量：展望符，代表当前状态下A后面可以紧跟的终结符。对于归约项目（$A\rarr\alpha\cdot,a$），代表输入符号为a时才能使用该产生式归约

            >   对于移入项目和待约项目（$A\rarr\alpha\cdot\beta, a且\beta\ne\epsilon$），**展望符与之无关**，但为了定义的完整，把它写出来了

    -   **等价**LR(1)项目/**展望符**的计算：

        -   第一分量：就是之前定义过的**等价项目**

        -   第二分量/展望符：要看等价项目产生式的**左部**在原项目中**右边的符号(串)**$\beta$。若$\beta$能推出空（或者$\beta$本身就是空的），则直接继承相同的展望符构成项目, 同时，对于$FIRST(\beta)$中的每个终结符，都可以再作为**展望符**与相同的**第一分量**构成一个等价的项目

            >   从计算展望符的角度讲，就要从初始项目$S'\rarr\cdot S,\$ $出发按照自动机的构造方法去计算了；第一分量相同的项目，可以合并到一起写，**展望符用/隔开**，但要知道这是多个项目

-   LR(1)的自动机和分析表

    >   相比于LR(0)，LR(1)对于CLOSURE、GOTO、项集族、自动机、分析表构造算法都做了适合于**展望符与归约项目**的修改

    -   自动机的构造：从初始项目$S'\rarr\cdot S,\$ $开始，与LR(0)的生成规则类似，只是在计算项目等价的时候要考虑**展望符**

    -   分析表的构造：

        -   对于不涉及归约项目的状态，处理方法与LR(0)相同

        -   对于涉及**归约项目**的状态，只有ACTION列(输入符号)是状态中归约项目的**展望符**时才能规约(且必须归约)

            >   之前构造SLR的时候，是遇到左部FOLLOW集中的符号都能规约

---

*LALR分析：*

-   LALR基本思想与概念

    -   LR(1)的状态过多，其中有些状态是可以合并的
    -   **同心项目集**（同心状态）：只保留第一分量时(重复的只留一个)，完全相同的项目集
    -   同心项目集是可以合并成一个状态的，其实是在对**展望符**进行合并

-   LALR的自动机与状态表

    -   自动机：在构造出的LR(1)自动机基础上，合并同心项目并修改边
    -   分析表：与LR(1)的构造方法相同

-   LALR的问题

    -   归约-归约冲突：同一个输入符，不知道该用状态中的哪个产生式归约了，因为它们的**展望符**都相同

    -   推迟错误发现：合并同心项集后，虽然不产生冲突，但可能会**推迟错误的发现**

        >   LALR分析法可能会作多余的**归约动作**，但绝不会作错误的**移进操作**。因为LALR其实是在合并展望符集合，而展望符与归约有关，与移进无关

-   LALR的特点

    -   形式上与LR(1)相同，都有**展望符**
    -   大小上与LR(0)/SLR相当，因为**合并了状态**
    -   分析能力上，SLR<LALR<LR。相比于SLR，LALR细化了状态；相比于LR(1)，LALR会延迟错误的发现。

