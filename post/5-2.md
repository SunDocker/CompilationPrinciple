### 5.3 语法制导翻译方案

-   基本思想

    -    语法制导翻译方案也叫**翻译模式**，给出了使用语义规则进行计算的**顺序**

-   SDD向SDT的转换

    -   S-SDD转换为SDT：
        -   将每个语义动作都放在**产生式右部的最右端**，代表在**规约**时计算属性值
        -   如果S-SDD的**基本文法**可以使用LR分析技术，那它的SDT就可以在LR分析过程中实现
    -   L-SDD转换为SDT：
        -   计算产生式左部符号**综合属性**的语义动作放在**产生式右部的最右端**
        -   计算产生式右部非终结符**继承属性**的语义动作插入**非终结符紧邻左边**

-   S-SDD的自底向上翻译

    -   扩展LR语法**分析栈**：在分析栈中附加一个域存储**综合属性**（值或指针），与文法符号平行（语义栈）
    -   分析栈的工作：在**规约**时执行语义动作，找到栈中对应位置的依赖，计算属性值，存入附加域

-   S-SDD的预测分析翻译

    -   文法改造

        -   消除左递归

            -   先消除左递归，再添加语义规则

            -   先添加语义规则，再消除左递归，并**添加新的语义规则**

                >   这就需要引入**继承属性**并插入**语义动作**，传递信息

    -   其他部分与L-SDD的翻译一致

-   L-SDD的预测分析翻译

    -   文法改造

    -   扩展预测分析栈

        -   继承属性在即将出现时计算，存放在**与非终结符平行的记录`A`**中（横向扩展、语义栈）
        -   综合属性在子结点分析完后计算，**新增一条综合记录`Asyn`**存放（纵向扩展）
        -   增加一种**动作记录`action`**，指向要执行的动作（纵向扩展）

    -   分析栈的工作

        -   依然按照右部**从右向左**的顺序入栈，**综合记录`syn`先**于本身记录入栈，动作记录`action`同样按照所处位置入栈

            >   往往会给语义动作对应的动作记录取一个简洁的**别名**

        -   栈内元素的出栈行为：

            -   栈顶为**动作记录**时，直接出栈并执行对应动作；

            -   栈顶为**综合记录**时，直接出栈并将**综合属性值传递**给栈内的特定语义动作；

            -   **变量本身记录**出栈时，若有继承属性，则要将**继承属性值传递**给入栈的特定语义动作；

            -   **终结符**出栈时要将**综合属性值**传递给栈中的特定语义动作

                >   这里的“传递”具体到程序上就是`stack[top+-n].xxx=stack[top].xxx, top=top+-n`，其中`top+-n`对应了语义动作出现的位置

        -   **综合属性**的计算：综合属性在对应产生式右部**最右端语义动作出栈**时计算

        -   **继承属性**的计算：变量本身记录的继承属性在对应产生式**紧邻左边动作出栈**时计算

            >   这里的“计算”具体到程序上，也是给`stk[top+-n]`赋值，涉及到一些计算，其中`top+-n`对应了综合记录或变量本身记录出现的位置

-   L-SDD的递归下降分析翻译

    -   文法改造

    -   在**递归下降分析**基础上，将非终结符的过程扩展为**函数**，参数为左部的**继承属性**，返回值为左部的**综合属性**

        >   递归的预测分析中过程调用的框架在这里要沿用

    -   对右部符号的每个属性都设置**局部变量**

        >   函数返回值由综合属性的局部变量接收

    -   将每个**语义动作**的代码依次加入函数体，使用对应的变量书写其动作逻辑

        -   继承属性局部变量的计算：按照**语义动作**计算并赋值给对应局部变量

        -   综合属性局部变量的计算：调用非终结符对应的函数

            >   终结符的话直接从token中取值

-   L-SDD的自底向上翻译

    -   **修改文法**以适应自底向上

        -   用各个“**标记非终结符**”替换**内嵌**的各个**语义动作**，每个标记非终结符都对应一条空产生式

        -   标记非终结符的空产生式最右端添加新语义动作

            -   将原动作依赖的属性作为**标记非终结符的继承属性**

            -   将原动作要计算的属性作为**标记非终结符的综合属性**来计算

                >   可以证明，如果一个文法是LL的，那么标记非终结符可以插入到产生式的任何位置，并且得到的文法是LR文法

    -   分析栈的工作

        -   与S-SDD基本一致，原继承属性的计算变成了**对标记非终结符综合属性的计算**
        -   计算标记非终结符时，要结合原产生式和继承属性的实际情况确定依赖位置和计算方式

