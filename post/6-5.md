*`switch-case`语句的翻译：*

-   `switch-case`的直观翻译方式：
    $$
    switch~E\{a_1\}\\ case~V_1:\{a_2\}S_1\{a_3\}\\ case~V_2:\{a_4\}S_2\{a_5\}\\ ...\\ case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\ default~:\{a_{2n}\}S_n\{a_{2n+1}\}
    $$

    -    新增特殊变量

         -   `Vk`：第`k`个分支的**入口值**
         -   `Lk`：存放第`k+1`个分支**第一条指令标号**的地址空间
         -   `t`：存放分支依据**表达式的值**
         -   `next`：存放整体代码块**下一条指令标号**的地址空间

         $$
         \begin{align} &a_1:\{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~next=newlabel();\\ &\}\\ &a_{2k-2}:\{\\ &~~~~label(L_{k-1});\\ &~~~~L_k=newlabel();\\ &~~~~gen(if~t~!=V_k~goto~L_k);\\ &\}\\ &a_{2k-1}:\{\\ &~~~~gen(goto~next);\\ &\}\\ &a_{2n}:\{\\ &~~~~label(L_{n-1});\\ &\}\\ &a_{2n+1}:\{\\ &~~~~label(next);\\ &\}\\ \end{align}
         $$

    -    `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

         >   那个`next=newlabel()`放在第一次使用`next`前也可以

    -    每个测试分支中，形成代码块前，先给该**分支对应标号赋值**，再生成**不满足条件跳转**至下一个分支标号的三地址码；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

         >   第一个测试分支不需要给自己的标号赋值，只需要生成不满足条件的跳转三地址码

    -    默认分支中，形成代码块前，给该**分支对应标号赋值**；形成代码块后，给**整体代码块下一条指令对应**的标号赋值

-   `switch-case`的**分支测试代码集中**翻译方式：
    $$
    switch~E\{a_1\}\\ case~V_1:\{a_2\}S_1\{a_3\}\\ case~V_2:\{a_4\}S_2\{a_5\}\\ ...\\ case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\ default~:\{a_{2n}\}S_n\{a_{2n+1}\}
    $$

    -    新增特殊变量

         -   `test`：分支集中测试块的第一条指令标号地址

    -    新增副作用

         -   `map`：记录分支测试**入口值**与分支测试**标号**的映射关系，方便批量生成**分支测试代码**

         $$
         \begin{align} &a_1:\{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~test=newlabel();\\ &~~~~gen(goto~test);\\ &~~~~next=newlabel();\\ &\}\\ &a_{2k-2}:\{\\ &~~~~L_k=newlabel();\\ &~~~~label(L_{k});\\ &~~~~map(V_k,L_k);\\ &\}\\ &a_{2k-1}:\{\\ &~~~~gen(goto~next);\\ &\}\\ &a_{2n}:\{\\ &~~~~L_n=newlabel();\\ &~~~~label(L_{n});\\ &\}\\ &a_{2n+1}:\{\\ &~~~~gen(goto~next);\\ &~~~~label(test);\\ &~~~~gen(if~t=V_k~goto~L_k);\\ &\}\\ \end{align}
         $$

    -    `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，生成**跳转至集中分支测试**的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

    -    每个测试分支中，形成代码块前，开辟该分支对应的标号，并给**标号赋值**为下一条指令，再将该分支测试**入口值**与**标号**的添加至映射表；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

    -    默认分支中，形成代码块前，开辟该分支对应的标号，并给**标号赋值**为下一条指令；形成代码块后，生成跳转至整体代码块下一条指令的三地址码，再给**集中分支测试的标号**赋值，然后根据**映射表**批量生成分支**入口值对比并跳转至对应标号**的三地址码

         >   可以增加一种`case`指令，`case t V L`等同于`if t==V goto L`，但`case`指令更容易被最终的代码生成器**探测**到，从而对这些指令进行**特殊处理**

---

*`for-to-step-do`语句的翻译：*

-   再说 吧

---

*`repeat-until`语句的翻译：*

-   再说 吧