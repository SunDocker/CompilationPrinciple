### 6.6 回填

*基本思想：*

-   生成**跳转**三地址码时，暂不指定跳转的**目标标号**，并将这样的指令放入**列表**中，同一个列表中所有跳转指令的**目标相同**，待能确定目标时，再**填充**列表中指令的目标标号

-   待填充跳转指令组成的**列表**会通过文法符号**综合属性**进行传递，不再需要使用`next true false`这类**继承属性**了，更符合**归约**的思想

>   如果不使用回填，可以两遍扫描，先把**语法分析树**建好，再遍历树，确定标号。但这样效率较低

---

*布尔表达式的回填：*

-   有改动或新增的文法符号及其综合属性
    -   `B`：布尔表达式
        -   `B.truelist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`B`的真出口**
        -   `B.falselist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`B`的假出口**
    -   `M`：辅助记录的符号
        -   `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到

-   新增的特殊变量
    -   `nextquad`：即将生成的下一条三地址码的标号

-   新增的副作用
    -   `makelist(i)`：创建一个只包含跳转指令`i`的列表，返回列表**指针**
    -   >   这里的`i`是这条跳转指令本身的标号，不是目标标号

    -   `merge(p1, p2)`：将`p1`和`p2`指向的两个列表合并，返回合并后列表**指针**
    -   `backpatch(p, i)`：将`i`作为**目标标号**填充`p`指向的列表中的所有**跳转指令**

-   有改动的语法规则和语义动作

    -   由**关系运算符**形成布尔表达式：$B\rarr E_1~relop~E_2\{a_1\}$

        $$
        \begin{align} &a_1:\{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~B.falselist=makelist(nextquad+1);\\ &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~\_);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
        $$

        >   先设置待**填充跳转指令列表**，把**即将生成的两条指令**分别加入真假出口对应的两个列表，再生成关系运算符的**待填充跳转三地址码**

    -   由**逻辑值**形成布尔表达式

        -   $B\rarr true\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
            $$

            >   先设置待**填充跳转指令列表**，把**即将生成的指令**加入真出口对应的列表，再生成**待填充的跳转三地址码**

        -   $B\rarr false\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B.falselist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align}
            $$

            >   先设置待**填充跳转指令列表**，把**即将生成的指令**加入假出口对应的列表，再生成**待填充的跳转三地址码**

    -   通过**逻辑运算符**连接布尔表达式

        -   $B\rarr(B_1)\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.truelist=B.truelist;\\ &~~~~B_1.falselist=B.falselist;\\ &\}\\ \end{align}
            $$

            >   子表达式形成后，让其**真、假出口列表**与父表达式保持相等

        -   $B\rarr not~B_1\{a_1\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~B_1.truelist=B.falselist;\\ &~~~~B_1.falselist=B.truelist;\\ &\}\\ \end{align}
            $$

            >   相反子表达式形成后，让其**真、假出口列表**与父表达式保持相反

        -   $B\rarr B_1~or~M~B_2\{a_1\}$

            $M\rarr\epsilon\{a_2\}$
            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(B_1.falselist,M.quad);\\ &~~~~B.truelist=merge(B_1.truelist,B_2.truelist);\\ &~~~~B.falselist=B_2.falselist;\\ &\}\\ &a_2:\{\\ &~~~~M.quad=nextquad;\\ &\}\\ \end{align}
            $$

            >   子表达式形成并连接后：
            >
            >   -   处理不短路的跳转位置：用记录下的第二个布尔表达式的**第一条指令标号**回填第一个子表达式的**假出口列表**
            >
            >   -   处理B的出口列表
            >       -   真出口合并：将两个子表达式的**真出口列表合并**至父表达式的真出口列表
            >       -   假出口：将第二个子表达式的**假出口列表**赋值给父表达式的假出口列表
            >
            >   父表达式的真假出口列表待**控制流语句**形成后回填

        -   $B\rarr B_1~and~M~B_2\{a_1\}$

            $M\rarr\epsilon\{a_2\}$
        
            $$
            \begin{align} &a_1:\{\\ &~~~~backpatch(B_1.truelist,M.quad);\\ &~~~~B.falselist=merge(B_1.falselist,B_2.falselist);\\ &~~~~B.truelist=B_2.truelist;\\ &\}\\ &a_2:\{\\ &~~~~M.quad=nextquad;\\ &\}\\ \end{align}
            $$
        
            >   子表达式形成并连接后：
            >
            >   -   处理不短路的跳转位置：用记录下的第二个布尔表达式的**第一条指令标号**回填第一个子表达式的**真出口列表**
            >-   处理B的出口列表
            >       -   假出口合并：将两个子表达式的**假出口列表合并**至父表达式的真出口列表
            >       -   真出口：将第二个子表达式的**真出口列表**赋值给父表达式的假出口列表
            >   
            >父表达式的真假出口列表待**控制流语句**形成后回填

---

