## 7 运行存储分配

### 7.1 运行存储分配概述

*运行存储分配策略：*

-   编译器要为源程序中出现的一些**数据对象**分配**运行时的存储空间**

-   静态存储分配策略：对于在编译时可以确定大小的**数据对象**，可以在**编译时**就静态地分配存储空间

    >   **静态**指的是**编译时、空间上**

-   动态存储分配策略：对于不能在编译时完全确定大小的**数据对象**，仅在编译时产生必要信息，而在**运行时**动态地分配存储空间
    
    >   **动态**指的是**运行时、时间上**
    
    -   栈式存储分配
    -   堆式存储分配

---

*名字与变量：*

-   概念问题：
    -   名字：编译时的名字
    -   变量/左值：运行时的内存位置
    -   标识符：名字的一种，指示数据对象的入口
    -   右值：运行时某一时刻变量的值

-   名字到值的映射
    -   `名字 --环境--> 左值/变量 --状态--> 值/右值`
    -   绑定：**环境**将**名字**绑定到**左值/变量**上

---

*内存划分与过程活动：*

-   运行时内存划分：
    -   **静态代码**区
    -   **静态数据**区
    -   **动态数据**区域
        -   **栈区**
        -   空闲内存
        -   堆区

-   活动记录：
    -   概念：
        -   活动(activation)：过程体的**每次执行**称为该过程的一个活动
        -   活动记录(activation record)：编译器以**过程**为单位、为**活动**分配的、用来管理**一次执行所需信息**的连续**存储空间**
    -   一般形式/构成
        -   实参
        -   返回值
        -   控制链/动态链：指向**调用者**的活动记录
        -   访问链/静态链：用于访问**非局部数据**
        -   保存的**机器状态**/机器状态字段：各种**寄存器**值和其他**状态信息**
        -   局部数据
        -   临时变量：中间代码生成时需要的临时变量

-   参数传递方式
    -   传值：新开变量，传右值
    -   传地址：如果实参是左值，则传左值；如果实参不是左值，则创建**临时变量**充当左值，设置其右值，然后传左值
    -   传值结果：同时传左值和右值，在主体中**只使用右值**，在**结束**前修改**左值状态**
    -   传名：过程体中用到形参的地方直接替换成一模一样的实参左值（包括运算符）

### 7.2 静态存储分配

>   静态数据和静态代码无疑是静态存储分配的，所以该小节主要讲**活动记录的静态存储分配**

*静态存储分配的规则与条件：*

-   规则：
    -   **编译器**为每个**活动记录**直接指定**存储位置**
    -   因此，过程中**标识符的存储位置**可以确定，每次都绑定到同样的存储单元，可以将这些地址编译到目标代码中

-   条件：
    -   **数组上下界**必须是常数
    
    -   不允许**递归调用**
    
    -   不允许**动态建立**数据实体
    
        >   满足这些条件的语言有BASIC、FORTRAN等

---

*顺序分配法：*

-   特点：
    -   按照过程出现的先后顺序**逐段分配**存储空间
    -   各过程的活动记录占用**互不相交**的存储空间

-   优点：处理简单

-   缺点：对内存空间的使用不够经济合理


---

*层次分配法：*

-   层次分配的特点：
    -   构建**过程调用图**，确保图中不出现**环**
    -   无相互调用关系的**并列过程**尽量使其局部数据**共享存储空间**

-   层次分配的算法：
    -   依据过程调用图，**从下至上**分配
    
    -   **同层**可以互相“**覆盖**”
    
    -   **上层**从子过程的**最高地址**开始分配
    
        >   代码实现的算法详见编译原理笔记仓库

### 7.3 栈式存储分配与调用返回序列

*栈式存储分配与活动树：*

-   栈式存储分配的概念：
    -   将过程的**活动记录**以**栈**的形式进行管理
    -   当过程被**调用**时，活动记录**入栈**；当过程**结束**时，活动记录**出栈**

-   栈式存储分配的优点：
    -   允许**活跃时段不交叠**的过程调用**共享存储空间**
    -   非局部变量的相对地址固定，与调用序列无关
        >   关于非局部变量会在后面讲到

-   活动树与控制栈：
    -   活动树的概念：描述程序运行期间控制**进入和离开各个活动**的情况的树
    -   活动树的结构：
        -   每个**结点**对应一个**活动**，根结点是**程序入口**过程的活动
        -   **子结点**表示被父结点活动**调用的活动**，按被调用的顺序自左向右排列
        -   一个子结点活动必须在其右兄弟结点活动开始之前结束
    -   活动树与控制栈的关系：
        -   活动树**根的活动记录**位于**栈底**，程序控制所在的活动记录位于**栈顶**
        -   **控制栈**中全部活动记录的**序列**对应于**活动树**中从**根结点**到达**当前控制**所在活动结点的**路径**

-   设计活动记录的原则：
    -   **传递的项**：调用者和被调用者之间**传递的值**放置在被调用活动记录的**起始位置**
    -   **固定长度项**：固定长度的项放置在活动记录的**中间位置**，包括**控制链、访问链、机器状态字段**
    -   **不定长度项**：初期不确定长度的项放置在活动记录的**尾部**
    -   **栈顶指针**：栈顶指针寄存器`top_sp`指向活动记录中**局部数据开始的位置**，以该位置作为**基地址**

---

*调用序列与返回序列：*

-   调用序列与返回序列概述：
    -   过程**调用**和过程**返回**都需要执行一些**代码**来管理**活动记录栈**，保存或恢复机器状态字等
    -   **调用序列**：实现**过程调用**的**代码段**。为活动记录**分配栈空间**，并填写活动记录的**字段**
    -   **返回序列**：实现**过程返回**的**代码段**。回收活动记录的栈空间，**恢复机器状态**，使**调用者过程**能继续执行
    -   调用序列和返回序列中的代码段通常被**分割到调用者过程和被调用者过程**中

-   **调用**序列的主要内容：
    -   参数：**调用者**计算实际参数的值
    -   返回地址：**调用者**将返回地址（当前程序计数器的值）存到被调用活动记录的**机器状态字段**中
    -   `top_sp`：**调用者**将`top_sp`的值存到被调用活动记录的**控制链**中，并**增加**`top_sp`的值，使其指向被调用活动记录**局部数据开始的位置**
    -   机器状态：**被调用者**保存寄存器值和其他状态信息（**保存现场**）
    -   局部数据：**被调用者**初始化其**局部数据**并开始执行
    -   访问链：**调用者**设置被调用活动记录的**访问链**
        >   关于访问链会在后面讲到

-   **返回**序列的主要内容：
    -   返回值：**被调用者**将**返回值**存到与**参数**相邻的位置
    -   `top_sp`：**被调用者**根据**控制链**中的数据恢复`top_sp`
        >   虽然`top_sp`的值被减小，但调用者依然可以知道**返回值**的位置
    -   机器状态：**被调用者**根据**机器状态字段**中的信息恢复寄存器值和其他状态信息（**恢复现场**）
    -   返回：**被调用者**根据**机器状态字段**中的信息跳转到**返回地址**

---

*变长数据的存储分配：*

-   变长数据的栈分配策略：
    -   编译时刻不能确定大小的过程**局部对象**可以分配到**运行时刻栈**中
    -   可以避免对变长数据空间的主动垃圾回收，减少相应开销
        >   现代程序设计语言中，编译时不能确定大小的对象往往分配在**堆区**，但如果是局部对象也可以分配到栈区

-   动态数组的分配：
    -   在活动记录的局部数据中存放**数组指针**
        >   **数组指针**在**编译时**可以确定大小，属于**活动记录**的一部分
    -   **运行**时在栈中**当前活动记录之下**开辟变长数组空间，存放数组元素
        >   变长数组虽然出现在栈中，但并不是**活动记录**的一部分，因为在**编译时**无法确定大小，需要在**运行时**动态分配

### 7.4 非局部数据与访问链

*非局部数据相关概念：*

-   非局部数据的概念：
    -   语言可分为**支持过程嵌套**声明的和**不支持过程嵌套**声明的
        -   >   支持过程嵌套：Pascal，不支持过程嵌套：C
    -   支持过程嵌套的语言中，过程可以使用**过程外定义的非局部数据**
        -   >   过程本就可以使用**过程自身定义**的局部数据和**全局定义**的数据。

        -   **全局**变量被分配在**静态区**，使用**静态**确定的地址访问它们
        -   **局部**变量被分配在**栈区**，在栈顶活动，通过**运行时**栈的`top_sp`访问

-   嵌套深度的概念：
    -   **过程**的嵌套深度：
        -   不内嵌在任何其他过程中的过程，其嵌套深度为1
        -   如果一个过程p在一个嵌套深度为i的过程中定义，则过程p的嵌套深度为i+1
    -   **变量**的嵌套深度：
        -   变量**声明所在过程**的嵌套深度即为该变量的嵌套深度

---

*访问链及其建立：*

-   访问链的概念：
    -   静态作用域规则：只要过程b嵌套在过程a的声明中，过程b就可以访问过程a中声明的对象
    -   访问链指针：在相互**嵌套**的过程的**活动记录**之间建立一种称为**访问链**的指针，使得内嵌的过程可以访问外层过程中声明的对象

-   访问链的建立：

    -   建立规则：如果**过程b**在源代码中**直接嵌套**在**过程a**中，那么**b的任何活动**中的访问链都指向最近的**a的活动**

        -   >   直接嵌套：过程b声明在过程a中且b的嵌套深度比a的嵌套深度大1
            >
            >   注意区分过程和活动，一个过程在运行时可以有多个活动

    -   建立步骤：建立访问链，其实就是在**调用序列**中加入相关代码，由**调用者**负责建立访问链

        -     假设嵌套深度为$n_x$的过程x调用嵌套深度为$n_y$的过程y（$x\rarr y$）

        -   如果$n_x<n_y$，即**外层调用内层**，那么需要在y的访问链中放置一个指向x的活动记录的指针

            >   这种情况下y一定是**直接定义**在x中的，因此$n_y=n_x+1$
            >
            >   因为外层**无法进一步深入内层**访问内层中的数据
            >
            >   外调内，内指外

        -   如果$n_x=n_y$，即**本层调用本层**，那么被调用活动记录的访问链与调用者活动记录相同，可以直接**复制**

            >   递归调用自己也是同理
            >
            >   同级调，**复制**

        -   如果$n_x>n_y$，即**内层调用外层**，那么从x的活动记录开始，沿着访问链经过$n_x-n_y+1$步找到的活动记录，就是y的访问链要指向的活动记录

            >   这种情况下，一定存在一个过程z，满足过程x**嵌套**在过程z中，且z中**直接定义**了过程y。在上述过程中经过$n_x-n_y+1$步找到的活动记录就是离栈顶最近的z的活动记录
            >
            >   -   这里说的“嵌套”不包括z直接定义x的情况，一定要存在一个嵌套的**中间过程**
            >
            >   内调外，指向最近**公共祖先**（不包括二者本身）

### 7.5 符号表的组织

>   由于本校考试不考查此部分，所以暂时没有知识总结

### 7.6 堆式存储分配

>   由于本校考试不考查此部分，所以暂时没有知识总结

## 8 代码优化

>   由于本校考试不考查此部分，所以暂时没有知识总结